<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Snake</title>
  </head>

  <body>
    <h1 style="text-align: center">Snake Game</h1>
    <div style="text-align: center">
      <canvas
        id="game_field"
        width="500px"
        height="500px"
        style="border: 1px solid black"
      >
      </canvas>
    </div>
  </body>

  <script>
    const canvas = document.getElementById("game_field");
    const context = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    const CELLS_COUNT = 20;
    const CELL_SIZE = Math.round(width / CELLS_COUNT);

    let snake = [];
    let food = null;
    let dir = null;
    let score = 0;
    let speedCoeff = 1;

    const FIELD_COLOR = "#f0f0f0";
    const FOOD_COLOR = "#FF0000";
    const GRID_COLOR = "#d9d9d9";
    const SNAKE_COLOR = "#00FF00";

    addEventListener("keydown", (e) => {
      if (e.keyCode === 37 && dir !== "right") {
        dir = "left";
      } else if (e.keyCode === 38 && dir !== "down") {
        dir = "up";
      } else if (e.keyCode === 39 && dir !== "left") {
        dir = "right";
      } else if (e.keyCode === 40 && dir !== "up") {
        dir = "down";
      }
    });

    const draw = () => {
      draw_field();
      draw_snake();
      draw_food();
    };

    const draw_field = () => {
      context.fillStyle = FIELD_COLOR;
      context.fillRect(0, 0, width, height);
      context.strokeStyle = GRID_COLOR;
      for (let i = CELL_SIZE; i < height; i += CELL_SIZE) {
        context.moveTo(0, i);
        context.lineTo(width, i);
        context.stroke();
      }
      for (let i = CELL_SIZE; i < width; i += CELL_SIZE) {
        context.moveTo(i, 0);
        context.lineTo(i, height);
        context.stroke();
      }
    };

    const draw_food = () => {
      context.beginPath();
      context.fillStyle = FOOD_COLOR;
      context.arc(
        food.x + CELL_SIZE / 2,
        food.y + CELL_SIZE / 2,
        CELL_SIZE / 2,
        0,
        2 * Math.PI
      );
      context.fill();
      context.closePath();
    };

    const draw_snake = () => {
      context.fillStyle = SNAKE_COLOR;
      context.strokeStyle = "#000000";
      for (let i = 0; i < snake.length; i++) {
        context.fillRect(snake[i].x, snake[i].y, CELL_SIZE, CELL_SIZE);
        context.strokeRect(snake[i].x, snake[i].y, CELL_SIZE, CELL_SIZE);
      }
    };

    const init = () => {
      snake = [];
      for (let i = 0; i < 2; ++i) {
        snake.push({
          x: i * CELL_SIZE,
          y: 0,
        });
        snake.reverse();
      }
      console.log(snake);
      dir = "right";
      score = 0;
      speedCoeff = 1;
      spawn_food();
    };

    // 인수에 따라 여러기능으로 사용하도록 만든 함수
    // 1) snake 몸통 충돌체크 , 사과 위치 & 몸통과 중복체크
    const isContact = (fieldObj) => {
      let contact = false;
      for (let i = 0; i < snake.length; i++) {
        // contact = snake[i].x === fieldObj.x && snake[i].y === fieldObj.y;
        // 뱀위치와 사과의 위치가 중복인지 확인하는 조건
        if (snake[i].x == fieldObj.x && snake[i].y == fieldObj.y) {
          contact = true;
          break;
        }
      }
      // 중복이면 return true
      // 중복이 아니면 return false
      // console.log(contact);
      return contact;
    };

    // 1) canvas 벽충돌 체크, 사과위치가 캔버스를 벗어나는지 체크
    const isValid = (pos) => {
      // return 0 <= pos.x && pos.x < width && 0 <= pos.y && pos.y < height;
      if (0 <= pos.x && pos.x < width && 0 <= pos.y && pos.y < height) {
        return true;
      }
      return false;
    };

    // 사과 랜덤위치 생성 및 while 조건으로 사과위치 & 뱀위치 중복 체크
    const spawn_food = () => {
      do {
        food = {
          x:
            Math.floor(Math.round(Math.random() * width) / CELL_SIZE) *
            CELL_SIZE,
          y:
            Math.floor(Math.round(Math.random() * height) / CELL_SIZE) *
            CELL_SIZE,
        };
      } while (isContact(food));
      // do while :
      // isContact의 리턴값이 true이면 do실행문이 실행
      // isContact의 리턴값이 false이면 반복문을 빠져나옴// 위치 중복이 없다.
    };

    const step = () => {
      let newPos = {};
      if (dir === "up") {
        newPos = {
          x: snake[0].x,
          y: snake[0].y - CELL_SIZE,
        };
      } else if (dir === "right") {
        newPos = {
          x: snake[0].x + CELL_SIZE,
          y: snake[0].y,
        };
      } else if (dir === "down") {
        newPos = {
          x: snake[0].x,
          y: snake[0].y + CELL_SIZE,
        };
      } else if (dir === "left") {
        newPos = {
          x: snake[0].x - CELL_SIZE,
          y: snake[0].y,
        };
      }
      console.log(newPos);

      // 종료 조건
      if (!isValid(newPos) || isContact(newPos)) {
        alert("Game over!\nYour score: " + score);
        init();
      
      // 사과 먹기
      } else if (newPos.x === food.x && newPos.y === food.y) {
        score++;
        if (score % 5 === 0) {
          speedCoeff += 0.25;
        }
        spawn_food();
        // snake 머리 추가
        snake.unshift({
          x: newPos.x,
          y: newPos.y,
        });
      } else {
        snake.pop();
        snake.unshift({
          x: newPos.x,
          y: newPos.y,
        });
      }
      draw();
      setTimeout(step, 100 / speedCoeff);
    };

    // draw();
    init();
    step();
  </script>
</html>
